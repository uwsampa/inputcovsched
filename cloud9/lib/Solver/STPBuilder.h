//===-- STPBuilder.h --------------------------------------------*- C++ -*-===//
//
//                     The KLEE Symbolic Virtual Machine
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#ifndef __UTIL_STPBUILDER_H__
#define __UTIL_STPBUILDER_H__

#include "klee/Constraints.h"
#include "klee/util/ExprHashMap.h"
#include "klee/Config/config.h"

#include <vector>
#include <map>
#include <set>

#define Expr VCExpr
#ifdef HAVE_EXT_STP
#include <stp/c_interface.h>
#else
#include "../../stp/c_interface/c_interface.h"
#endif

#if ENABLE_STPLOG == 1
#include "stp/stplog.h"
#endif
#undef Expr

namespace klee {

//-----------------------------------------------------------------------------
// Reference counting of VCExprs
//-----------------------------------------------------------------------------

class ExprHolder {
  friend class ExprHandle;
  ::VCExpr expr;
  unsigned count;

public:
  ExprHolder(const ::VCExpr _expr) : expr(_expr), count(0) {}
  ~ExprHolder() {
    if (expr) vc_DeleteExpr(expr);
  }
};

class ExprArrayHolder {
  friend class ExprHandle;
  ::VCExpr *exprs;
  int size;

public:
  ExprArrayHolder(::VCExpr *_exprs, int size) : exprs(_exprs), size(size) {}
  ~ExprArrayHolder() {
    if (exprs && size) {
      for (int k = 0; k < size; ++k)
        vc_DeleteExpr(exprs[k]);
      free(exprs);
    }
  }
};

class ExprHandle {
  ExprHolder *H;

public:
  ExprHandle() : H(new ExprHolder(0)) { H->count++; }
  ExprHandle(::VCExpr _expr) : H(new ExprHolder(_expr)) { H->count++; }
  ExprHandle(const ExprHandle &b) : H(b.H) { H->count++; }
  ~ExprHandle() { if (--H->count == 0) delete H; }

  ExprHandle &operator=(const ExprHandle &b) {
    if (--H->count == 0) delete H;
    H = b.H;
    H->count++;
    return *this;
  }

  operator bool () const { return H->expr; }
  operator ::VCExpr () const { return H->expr; }
};

//-----------------------------------------------------------------------------
// Building STP queries
//-----------------------------------------------------------------------------

class STPBuilder {
  const ::VC vc;

  typedef std::vector< ExprHandle > ExprHandleList;

  /// Construction cache
  typedef ExprHashMap< std::pair<ExprHandle, unsigned> > ConstructedCacheTy;
  ConstructedCacheTy _constructed;

  /// Used for quantifier instantiation
  struct InstantiatedSet {
    ExprHashSet done;  // completed instantiations (values for qvar)
    ExprHandleList *dst;   // where to put the final instantiations

    InstantiatedSet() : dst(NULL) {}
  };

  /// Two-level quantifier worklist:
  ///   foreach array, there is a set of quantified constraints to instantiate
  ///   foreach constraint, there is a set of indices that have been instantiated
  typedef std::map<const Array*, std::map<ref<ForallExpr>, InstantiatedSet> > OnArrayReadWorklistTy;
  OnArrayReadWorklistTy _onArrayReadWorklist;

  /// Extra assumptions generated by construct()
  /// Notably, this includes instantiations of quantified constraints
  ExprHandleList _assumptions;

  /// Rewrite division and remainders by constants into multiplies and
  /// shifts. STP should probably handle this for us.
  const bool _optimizeDivides;

private:
  unsigned getShiftBits(unsigned amount) {
    return (amount > 32) ? 6 : 5;
  }

  ExprHandle bvOne(unsigned width);
  ExprHandle bvZero(unsigned width);
  ExprHandle bvMinusOne(unsigned width);
  ExprHandle bvConst32(unsigned width, uint32_t value);
  ExprHandle bvConst64(unsigned width, uint64_t value);

  ExprHandle bvBoolExtract(ExprHandle expr, int bit);
  ExprHandle bvExtract(ExprHandle expr, unsigned top, unsigned bottom);
  ExprHandle eqExpr(ExprHandle a, ExprHandle b);

  //logical left and right shift (not arithmetic)
  ExprHandle bvLeftShiftByConstant(ExprHandle expr, unsigned amount, unsigned shiftBits);
  ExprHandle bvRightShiftByConstant(ExprHandle expr, unsigned amount, unsigned shiftBits);
  ExprHandle bvArithRightShiftByConstant(ExprHandle expr, unsigned amount, ExprHandle isSigned, unsigned shiftBits);

  ExprHandle bvLeftShift(ExprHandle expr, ExprHandle amount, unsigned width);
  ExprHandle bvRightShift(ExprHandle expr, ExprHandle amount, unsigned width);
  ExprHandle bvArithRightShift(ExprHandle expr, ExprHandle amount, unsigned width);

  ExprHandle constructMulByConstant(ExprHandle expr, unsigned width, uint64_t x);
  ExprHandle constructUDivByConstant(ExprHandle expr_n, unsigned width, uint64_t d);
  ExprHandle constructSDivByConstant(ExprHandle expr_n, unsigned width, uint64_t d);

  ExprHandle constructReadExpr(const ReadExpr *re);
  ExprHandle constructActual(ref<Expr> e, int *width_out);
  ExprHandle construct(ref<Expr> e, int *width_out);

  ExprHandle construct(ref<Expr> e) {
    return construct(e, NULL);
  }

  void scanTriggers(ref<Expr> e, ExprHandleList *target);

  template<class Iterator>
  void processExprs(Iterator begin, Iterator end,
                    ExprHandleList *constructed, ExprHandleList *triggerDst);

  ::VCExpr buildArray(const char *name, unsigned indexWidth, unsigned valueWidth);
  void processArrayReadTriggers(const Array *root, const ref<Expr> &index);

public:
  STPBuilder(::VC vc, bool optimizeDivides=true);
  ~STPBuilder();

  void clearCaches();

  ExprHandle getTrue();
  ExprHandle getFalse();
  ::VCExpr getInitialArray(const Array *os);

  // N.B.: All foralls must be at the top-level of each constraint
  void assertAssumptions(const ConstraintManager &constraints);

  // N.B.: All foralls must be at the top-level of each term in "e",
  // where "e" is a boolean conjunction.  (We special-case !e, so the
  // conjunction can be nested under a negation.)  If "e" is not a
  // boolean conjunction, then foralls are not allowed.
  ExprHandle constructQuery(ref<Expr> e);
};

}

#endif
