/*
 * Input Covering Schedules
 * Author: Tom Bergan
 *
 * A wrapper class for running AliasAnalysis passes outside of PassManagers.
 * This is a majorly ugly hack.  The goal is to run an AliasAnalysis pass for
 * use in Klee, without refactoring Klee to run inside an llvm PassManager.
 * To do this, you might create a local PassManager, add AliasAnalysis passes,
 * then run the passes.  This works right?  Nope!  The PassManager is too smart:
 * it realizes that once all passes have run, the analyses generated by the
 * passes (DSGraphs for DSAA, or call graphs for GlobalsModRef) are no longer
 * needed, so it calls releaseMemory() on all AA passes, wiping that data!
 * To avoid this, we write a custom ModulePass that does nothing but mark the
 * desired AA passes "required", then signals a condition variable, then goes
 * to sleep.  The main Klee thread should spawn this pass in a new thread then
 * wait for the condition variable to be signaled before continuing.
 *
 * USAGE:
 *   AARunner runner;   // global scope or on the heap
 *   runner.RunAliasAnalysis(&Module);
 *   runner.getAA();    // analysis lives for the lifetime of runner
 *
 */

#ifndef ICS_AARUNNER_H
#define ICS_AARUNNER_H

#include "llvm/PassManager.h"
#include "llvm/Module.h"
#include "dsa/DataStructureAA.h"
#include <pthread.h>

namespace ics {

class AARunner {
private:
  // The dummy pass which spins forever
  struct DoNothing : public llvm::ModulePass {
    pthread_cond_t  *_ready;
    pthread_cond_t  *_done;
    pthread_mutex_t *_mutex;

    static char ID;
    DoNothing(pthread_cond_t *r, pthread_cond_t *d, pthread_mutex_t *m)
      : ModulePass(ID), _ready(r), _done(d), _mutex(m)
    {}

    virtual void getAnalysisUsage(llvm::AnalysisUsage &AU) const {
      AU.setPreservesAll();
      AU.addRequiredTransitive<llvm::AliasAnalysis>();
    }

    virtual bool runOnModule(llvm::Module &M) {
      CLOUD9_DEBUG("AliasAnalysis complete");
      pthread_mutex_lock(_mutex);
      pthread_cond_broadcast(_ready);
      pthread_cond_wait(_done, _mutex);
      pthread_mutex_unlock(_mutex);
      return false;
    }
  };

private:
  DoNothing    *_dummy;
  llvm::Module *_module;
  llvm::DSAA   *_dsaa;
  bool _dummyLive;

  pthread_mutex_t _mutex;
  pthread_cond_t  _ready;
  pthread_cond_t  _done;
  pthread_t       _thread;

public:
  AARunner() : _dummy(NULL), _module(NULL), _dsaa(NULL), _dummyLive(false) {
    pthread_mutex_init(&_mutex, NULL);
    pthread_cond_init(&_ready, NULL);
    pthread_cond_init(&_done, NULL);
  }
  ~AARunner() {
    DoneWithAliasAnalysis();
    pthread_mutex_destroy(&_mutex);
    pthread_cond_destroy(&_ready);
    pthread_cond_destroy(&_done);
  }

  void RunAliasAnalysis(llvm::Module *module) {
    _module = module;
    _dummyLive = true;

    // Spawn the thread
    pthread_mutex_lock(&_mutex);
    int r = pthread_create(&_thread, NULL, &AARunner::RunThread, reinterpret_cast<void*>(this));
    if (r != 0) {
      perror("AARunner::RunAliasAnalysis: pthread_create");
      exit(1);
    }

    // Wait for AliasAnalysis to complete
    pthread_cond_wait(&_ready, &_mutex);
    pthread_mutex_unlock(&_mutex);
  }

  void DoneWithAliasAnalysis() {
    if (!_dummyLive)
      return;

    // Tell the thread it can exit
    pthread_mutex_lock(&_mutex);
    pthread_cond_broadcast(&_done);
    pthread_mutex_unlock(&_mutex);

    // Wait for the thread to exit
    pthread_join(_thread, NULL);
    _dummyLive = false;
  }

  llvm::AliasAnalysis* getAA() {
    return &_dummy->getAnalysis<llvm::AliasAnalysis>();
  }

  llvm::DSAA* getDSAA() {
    return _dsaa;
  }

  static void* RunThread(void *in) {
    AARunner *runner = reinterpret_cast<AARunner*>(in);
    runner->_dummy = new DoNothing(&runner->_ready, &runner->_done, &runner->_mutex);
    runner->_dsaa = static_cast<llvm::DSAA*>(llvm::createDSAAPass());

    CLOUD9_DEBUG("AliasAnalysis thread started");

    llvm::PassManager PM;
    PM.add(new llvm::TargetData(runner->_module));
    PM.add(llvm::createBasicAliasAnalysisPass());
    PM.add(llvm::createGlobalsModRefPass());
    PM.add(runner->_dsaa);
    PM.add(runner->_dummy);
    PM.run(*runner->_module);

    CLOUD9_DEBUG("AliasAnalysis thread exited");

    return NULL;
  }
};

}  // namespace ics

#endif
