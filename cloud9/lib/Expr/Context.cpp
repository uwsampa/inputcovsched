//===-- Context.cpp -------------------------------------------------------===//
//
//                     The KLEE Symbolic Virtual Machine
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#include "klee/Expr.h"
#include "klee/Context.h"

#include "llvm/Type.h"
#include "llvm/DerivedTypes.h"

#include <cassert>

using namespace klee;

static bool Initialized = false;
static Context TheContext;

void Context::initialize(bool IsLittleEndian, Expr::Width PointerWidth) {
  assert(!Initialized && "Duplicate context initialization!");
  TheContext = Context(IsLittleEndian, PointerWidth);
  Initialized = true;
  Expr::initialize();
}

const Context &Context::get() {
  assert(Initialized && "Context has not been initialized!");
  return TheContext;
}

// FIXME: This is a total hack, just to avoid a layering issue until this stuff
// moves out of Expr.

void Expr::initialize() {
  Null = Expr::createPointer(0);

  True = ConstantExpr::create(1, Expr::Bool);
  False = ConstantExpr::create(0, Expr::Bool);

  Zero8 = ConstantExpr::create(0, Expr::Int8);
  Zero32 = ConstantExpr::create(0, Expr::Int32);

  One8 = ConstantExpr::create(1, Expr::Int8);
  One32 = ConstantExpr::create(1, Expr::Int32);
}

ref<Expr> Expr::createCoerceToPointerType(ref<Expr> e) {
  return ZExtExpr::create(e, Context::get().getPointerWidth());
}

ref<ConstantExpr> Expr::createPointer(uint64_t v) {
  // We anticipate there will be relatively few of these, so always cache them
  return ConstantExpr::createCached(v, Context::get().getPointerWidth());
}

ref<Expr> Expr::createArrayRead(const Array *array, Expr::Width width) {
  return createArrayReadAtIndex(array, Expr::Zero32, width, Context::get().isLittleEndian());
}

ref<Expr> Expr::createArrayReadAtIndex(const Array *array, ref<Expr> baseIndex, Expr::Width width) {
  return createArrayReadAtIndex(array, baseIndex, width, Context::get().isLittleEndian());
}

ref<Expr> Expr::createMultibyteRead(const UpdateList &updates, ref<Expr> baseIndex, const unsigned nbytes) {
  return createMultibyteRead(updates, baseIndex, nbytes, Context::get().isLittleEndian());
}

ref<ReadExpr> Expr::getLowestByteOfSymbolicRead(ref<Expr> e) {
  // Assuming that Expr::isSymbolicRead(e), and further assuming that e
  // fits the form generated by ObjectState::read and Expr::createArrayRead,
  // find the nested ReadExpr that reads from the lowest address.
  ref<ReadExpr> read = dyn_cast<ReadExpr>(e);
  if (read.get())
    return read;

  ref<ConcatExpr> concat = dyn_cast<ConcatExpr>(e);
  if (!concat.get())
    return NULL;

  // BigEndian: left-most read
  if (!Context::get().isLittleEndian())
    return dyn_cast<ReadExpr>(concat->left);

  // LittleEndian: right-most read
  for (;;) {
    read = dyn_cast<ReadExpr>(concat->right);
    if (read.get())
      return read;

    concat = dyn_cast<ConcatExpr>(concat->right);
    if (!concat.get())
      return NULL;
  }
}

ref<ReadExpr> Expr::hasOrderedReads(ref<Expr> e) {
  const int stride = Context::get().isLittleEndian() ? -1 : 1;
  return Expr::hasOrderedReads(e, stride);
}
