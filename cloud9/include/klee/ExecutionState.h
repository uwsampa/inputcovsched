//===-- ExecutionState.h ----------------------------------------*- C++ -*-===//
//
//                     The KLEE Symbolic Virtual Machine
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#ifndef KLEE_EXECUTIONSTATE_H
#define KLEE_EXECUTIONSTATE_H

#include "klee/Constraints.h"
#include "klee/Expr.h"
#include "klee/util/RefCounted.h"
#include "klee/Internal/ADT/TreeStream.h"

// FIXME: We do not want to be exposing these? :(
#include "../../lib/Core/AddressSpace.h"
#include "klee/Internal/Module/KInstIterator.h"
#include "klee/Internal/Module/Cell.h"
#include "klee/util/ExprHashMap.h"
#include "klee/util/RefCounted.h"

#include "llvm/ADT/DenseMap.h"
#include "llvm/ADT/SmallPtrSet.h"
#include "llvm/Support/TimeValue.h"

#include "klee/Threading.h"
#include "klee/MultiProcess.h"
#include "klee/AddressPool.h"
#include "klee/StackTrace.h"
#include "klee/SymbolicObjectTable.h"
#include "klee/SyncInvariantsUtil.h"

#include "ics/PrecondSliceTrace.h"
#include "ics/HBGraph.h"
#include "ics/ForkableTrace.h"

#include <map>
#include <set>
#include <queue>
#include <vector>

namespace cloud9 {
namespace worker {
class SymbolicState;
}
}

namespace llvm {
class Instruction;
class Value;
class GlobalValue;
}

namespace klee {
  class Array;
  class CallPathNode;
  struct KFunction;
  struct KInstruction;
  class MemoryObject;
  class PTreeNode;
  struct InstructionInfo;
  class Executor;

  class ExecutionState;

namespace c9 {
std::ostream &printStateStack(std::ostream &os, const ExecutionState &state);
std::ostream &printStateConstraints(std::ostream &os, const ExecutionState &state);
std::ostream &printStateMemorySummary(std::ostream &os, const ExecutionState &state);
}

std::ostream &operator<<(std::ostream &os, const ExecutionState &state); // XXX Cloud9 hack
std::ostream &operator<<(std::ostream &os, const MemoryMap &mm);

class ExecutionState {
public:
  friend class ObjectState;

  typedef std::map<process_id_t, Process> processes_ty;
  typedef std::map<ThreadUid, Thread> threads_ty;
  typedef std::vector<StackFrame> stack_ty;
  typedef std::vector<ThreadUid> wlist_ty;

private:
  // unsupported, use copy constructor
  ExecutionState &operator=(const ExecutionState&); 
  std::map< std::string, std::string > fnAliases;

  cloud9::worker::SymbolicState *c9State;

  void setupMain(KFunction *kf);
  void setupTime();

public:
  //////////////////////////////////////////////////////////////////////////////
  // Klee State
  //////////////////////////////////////////////////////////////////////////////

  // System-level parameters
  Executor *executor;

  // Instruction counter
  uint64_t stateTime;

  // Depth of this state in the execution tree
  unsigned depth;

  // Total number of program branches executed (i.e., all br and switch instructions)
  unsigned totalBranches;
  bool totalBranchesCounterEnabled;

  // Disables forking, set by user code.
  bool forkDisabled;

  // Was this state discarded via Executor::discardState()?
  bool discarded;

  // For search hueristics
  bool coveredNew;
  llvm::sys::TimeValue lastCoveredTime;
  unsigned instsSinceCovNew;

  void setCoveredNew() {
    coveredNew = true;
    lastCoveredTime = llvm::sys::TimeValue::now();
  }

  mutable double queryCost;
  double weight;

  std::map<const std::string*, std::set<unsigned> > coveredLines;

  // The execution tree
  PTreeNode *ptreeNode;
  TreeOStream pathOS, symPathOS;

  // Set of symbolics for the current path
  // Used to generate test cases
  typedef ImmutableSet<const SymbolicObject*> SymbolicsSetTy;
  SymbolicsSetTy symbolics;

  // Set of used array names.  Used to avoid collisions.
  // Shared by all states to avoid copying (can't hurt to share this).
  ref< RefCounted<std::set<std::string> > > arrayNames;
  std::string uniquifyArrayName(const std::string &name);

  // Summary of constrants generated by branches or other concretization
  ConstraintManager globalConstraints;

  // This is empty until the state terminates, at which point it is either
  // an error msg (for paths that ended in error), or "" (for successful paths).
  std::string finalErrorCode;

  //////////////////////////////////////////////////////////////////////////////
  // Cloud9 State
  //////////////////////////////////////////////////////////////////////////////

  // For a multithreaded ExecutionState
  threads_ty threads;
  threads_ty zombies;
  processes_ty processes;

  threads_ty::iterator crtThreadIt;
  processes_ty::iterator crtProcessIt;
  unsigned int preemptions;

  wlist_ty theWaitingList;
  wlist_id_t waitingListIdCounter;

  AddressPool addressPool;
  AddressSpace::cow_domain_t cowDomain;

  // Per-thread instruction counter
  std::map<ThreadUid, size_t> perThreadTime;

  // Thread-local variable addresses
  // These tables are shared by all states that share a given thread
  typedef llvm::DenseMap<const llvm::GlobalValue*, Cell> ThreadLocalsTableTy;
  typedef ImmutableMap<ThreadUid, ref< RefCounted<ThreadLocalsTableTy> > > ThreadLocalsTy;
  ThreadLocalsTy threadLocals;

  // Thread management
  Thread& createThread(thread_id_t tid, KFunction *kf);
  Process& forkProcess(process_id_t pid);
  void terminateThread(threads_ty::iterator it);
  void terminateProcess(processes_ty::iterator it);
  void zombifyThread(threads_ty::iterator it);

  // Thread scheduling
  threads_ty::iterator nextThread(threads_ty::iterator it) {
    if (it == threads.end())
      it = threads.begin();
    else {
      it++;
      if (it == threads.end())
        it = threads.begin();
    }

    crtProcessIt = processes.find(crtThreadIt->second.getPid());
    return it;
  }

  threads_ty::iterator nextEnabledThread(threads_ty::iterator it) {
    it = nextThread(it);
    while (!it->second.enabled)
      it = nextThread(it);
    return it;
  }

  void scheduleNext(threads_ty::iterator it);

  // Waiting lists
  wlist_id_t newWaitingListId() { return waitingListIdCounter++; }
  void sleepThread(const WaitingListKey &wl);
  void wakeThread(const ThreadUid tuid, const ThreadUid *waker = NULL);
  void wakeThreads(const std::set<ThreadUid> &tuids, const ThreadUid *waker = NULL);
  size_t enabledCount();

  //////////////////////////////////////////////////////////////////////////////
  // ICS State
  //////////////////////////////////////////////////////////////////////////////

  // For partial eval (see ExecutorUtil.cpp)
  enum {
    NotPartialEval  = 0,
    PartialEvalInit = 1,
    PartialEvalComputeFnSummaries = -1,
    PartialEvalDataflow = -2
  };
  int partialEvalMode;
  const llvm::Instruction *partialEvalTarget;

  // The "input harness" is the initial program context from which we begin
  // symbolic execution.  Partial eval computes the initial state for this
  // context.  The "inputHarnessConstraints" are assumptions that are valid on
  // every path executed from the current initial program context.
  ::ics::PrecondSliceTrace inputHarnessTrace;
  ConstraintManager inputHarnessConstraints;

  // A list of all MemoryObjects allocated on the current path that *might*
  // alias a symbolic pointer.  This includes both (a) all objects allocated
  // before the region harness, and (b) all objects allocated during symbolic
  // pointer resolution.  We pair each object with its ObjectState as of the
  // region harness (where the ObjectState is represented via the UpdateList).
  typedef ::ics::ForkableTrace<const MemoryObject*> HarnessObjectListTy;
  HarnessObjectListTy inputHarnessObjects;

  // The set of symbolic objects that have been dynamically initialized using
  // synchronization invariants.  See usage in SpecialFunctionHandler and the
  // way SpecialFunctionHandler is invoked by the pthread model functions.
  typedef ImmutableMap<wlist_syncop_t, ImmutableExprSet> InitializedAddrsMap;
  InitializedAddrsMap initializedAddrs;

  // A set of "pseudo symbolic ptrs".  We have to be careful to not refer to
  // symbolic-sized objects via a concrete ptr (for rationale, see comments for
  // AddressSpace::objects).  Thus, we refer to such objects using symbols.
  // This table maps symbols -> objects.
  typedef ImmutableMap<ref<Expr>, const MemoryObject*> PseudoSymbolicPtrTable;
  PseudoSymbolicPtrTable pseudoSymbolicPtrs;

  // The set of symbolic ptrs that have been resolved on any path.
  // This also maintains a set of pts resolve in the current path (the
  // later is used when generating secondary alias sets and constraints).
  SymbolicPtrResolutionTable resolvedSymbolicPtrs;

  // The set of all symbolic objects that have been allocated on any path.
  SymbolicObjectTable symbolicObjects;

  // An address pool used to allocate MemoryObjects for symbolic ptr
  // resolution.  These must live for the entire execution: hence, it
  // is refcounted and shared among all paths.
  ref< RefCounted<AddressPool> >  symbolicAddressPool;

  // For ForkOnSchedule
  std::queue<ThreadUid> ctxSwitchesToReplay;

  // For ICS
  ::ics::HBGraph hbGraph;
  ::ics::PrecondSliceTrace precondSliceTrace;
  std::set<ThreadUid> waitingAtIcsRegion;

  void sleepThreadForEndOfIcsRegion(const ThreadUid tuid);
  void clearWaitingAtIcsRegion();

  // For synchronization invariants
  LocksetMapTy locksets;
  BarrierInitCounts barrierInitCounts;

  // For heuristics: set to true when a thread crosses a potential region
  // boundary by jumping into or around a "covered" loop.
  std::map<ThreadUid, bool> crossedIcsLoopedRegion;

  // For klee_ics_once_per_region()
  ImmutableSet<KInstruction*> oncePerRegionCalls;

public:
  //////////////////////////////////////////////////////////////////////////////
  // Methods
  //////////////////////////////////////////////////////////////////////////////

  // Shortcut methods
  Thread &crtThread() { return crtThreadIt->second; }
  const Thread &crtThread() const { return crtThreadIt->second; }
  const ThreadUid &crtThreadUid() const { return crtThreadIt->first; }

  Process &crtProcess() { return crtProcessIt->second; }
  const Process &crtProcess() const { return crtProcessIt->second; }
  const process_id_t &crtProcessId() const { return crtProcessIt->first; }

  ConstraintManager &constraints() { return globalConstraints; }
  const ConstraintManager &constraints() const { return globalConstraints; }

  AddressSpace &addressSpace() { return crtProcess().addressSpace; }
  const AddressSpace &addressSpace() const { return crtProcess().addressSpace; }

  KInstIterator& pc() { return crtThread().pc; }
  const KInstIterator& pc() const { return crtThread().pc; }

  KInstIterator& prevPC() { return crtThread().prevPC; }
  const KInstIterator& prevPC() const { return crtThread().prevPC; }

  stack_ty& stack() { return crtThread().stack; }
  const stack_ty& stack() const { return crtThread().stack; }

  const ThreadLocalsTableTy* getThreadLocalsFor(const ThreadUid tuid) const  {
    const ThreadLocalsTy::value_type *x = threadLocals.lookup(tuid);
    return x ? x->second.get() : NULL;
  }

  static const Cell* lookupThreadLocalAddress(const ThreadLocalsTableTy *table,
                                              const llvm::GlobalValue *var) {
    if (table) {
      ThreadLocalsTableTy::const_iterator it = table->find(var);
      if (it != table->end())
        return &it->second;
    }
    return NULL;
  }

  const Cell* lookupThreadLocalAddress(const ThreadUid tuid, const llvm::GlobalValue *var) const {
    return lookupThreadLocalAddress(getThreadLocalsFor(tuid), var);
  }

  const ThreadLocalsTableTy* crtThreadLocals() const  {
    return getThreadLocalsFor(crtThreadUid());
  }

  const Cell* lookupCrtThreadLocalAddress(const llvm::GlobalValue *var) const  {
    return lookupThreadLocalAddress(crtThreadUid(), var);
  }

  const MemoryObject* lookupPseudoSymbolicPtr(const ref<Expr> &ptr) const {
    if (const PseudoSymbolicPtrTable::value_type* pseudo = pseudoSymbolicPtrs.lookup(ptr))
      return pseudo->second;
    return NULL;
  }

  // Misc
  std::string getFnAlias(std::string fn);
  void addFnAlias(std::string old_fn, std::string new_fn);
  void removeFnAlias(std::string fn);

public:
  ExecutionState(Executor *_executor, KFunction *kf);

  // XXX total hack, just used to make a state so solver can
  // use on structure
  ExecutionState(Executor *_executor, const std::vector<ref<Expr> > &assumptions);

  ~ExecutionState();
  
  ExecutionState *branch();

  void pushFrame(Thread &t, KInstIterator caller, KFunction *kf) {
    t.stack.push_back(StackFrame(caller,kf));
  }
  void pushFrame(KInstIterator caller, KFunction *kf) {
    pushFrame(crtThread(), caller, kf);
  }

  void popFrame(Thread &t) {
    StackFrame &sf = t.stack.back();
    Process &p = processes.find(t.getPid())->second;
    for (std::vector<const MemoryObject*>::iterator
         it = sf.allocas.begin(), ie = sf.allocas.end(); it != ie; ++it) {
      p.addressSpace.unbindObject(*it);
    }
    t.stack.pop_back();
  }
  void popFrame() {
    popFrame(crtThread());
  }

  void addConstraint(ref<Expr> e) { 
    constraints().addConstraint(e);
  }

  const Array* addSymbolicInput(const llvm::Instruction *inst,
                                const MemoryObject *mo,
                                const char *name);

  bool merge(const ExecutionState &b);

  StackTrace getStackTrace() const;
  StackTrace getStackTrace(const Thread &thread) const;
  void dumpStackTrace(std::ostream &out) const;
  void dumpStackTrace() const;   // to std::cerr: easy to call from a debugger

  // Cloud9 integration

  cloud9::worker::SymbolicState *getCloud9State() const { return c9State; }
  void setCloud9State(cloud9::worker::SymbolicState *state) { c9State = state; }
};

}

#endif
